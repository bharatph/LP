# Lazy Protocol (LP)
Lazy is a session-aware protocol for maintaining anonymous and uninterrupted connections.
The name Lazy protocol because the protocol so simple even a lazy programmer can understand.

#### Characteristics of the Lazy Protocol
* Operations are based on the context
* Non-Authenticative
* Connection is alive through sessions

#### Transport Format
The following algorithm is used for sending and retrieving the information to and from the server

The following codes are used while transporting through LP

| Protocol Code | Code Information          |
|---------------|---------------------------|
| CON_REQ       | Requesting for connection |
| CON_ACK       | Connection acknowleged    |
| BIN_REQ       | Request binary            |
| BIN_ACK       | Receive binary            |
| BIN_ERR       | Binary send error         |
| TXT_REQ       | Request text              |
| TXT_ACK       | Receive text              |
| TXT_ERR       | Text send error           |

The Non-Authenticative model of LP makes it possible to cut short codes and keep the protocol commands simple. Because the only required information from server is whether it can receive/send the file. Since number of codes to check is very less, the performance can be more than optimal in some cases.

#### Session
In LP connections are identified through sessions. Session based connections are a advantage because of the following reasons,
* Connection can be restored to the same state when disconnected
* Connections are manageable, i.e. they are disposable and restoreable
* A session based connection can live  forever

A Session has the following properties
* session_id
* session_rec

LP maintains a session_id to identify a session. This session_id is used when the connection is interupted when a file is being uploaded to the server. This ensures that the uploaded files are not uploaded again when reconnecting. The session_id is a hash generated by the SHA-2 256 bit algorithm. The hash is based on a randomly generated input of 256bits. Thus it makes the probability of finding a collision a even lesser.

Every session_id is mapped to a session_rec. A session_rec is a abstract object containing the session information. session_rec is based on the implementation of LP

It is not mandatory that the session_id and the session_rec has one to one correspondence

| session_id                 | session_rec  |
|----------------------------|--------------|
| 4sdfscqaxcvzrfsdwe...dfsd3 | session1.txt |
| gs34ssqaxcvzrfsdwe...qfw3  | session2.txt |
| .                          | .            |
| .                          | .            |

The session_id is expired after MAX_SES_TIME hrs of inactivity.


The Session when is inactive is restored again by sending a **CON_ACK** along with the session_id. The session is restored if already present or a new one is created if the session_id is not recognizable.

#### Internal Working
The following is algorithm is the usage of this protocol

#### C API
```c
int lp_init_session(int sock); //initialise a session to the server
int lp_send_binary(int sock, const void *binary); //send file to server
int lp_send_text(int sock, const char *text); //send text to server
```
